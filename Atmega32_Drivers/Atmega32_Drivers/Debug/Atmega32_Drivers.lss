
Atmega32_Drivers.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000596  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000004c  00800060  00000596  0000060a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .comment      00000030  00000000  00000000  00000656  2**0
                  CONTENTS, READONLY
  3 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00000688  2**2
                  CONTENTS, READONLY
  4 .debug_aranges 00000180  00000000  00000000  000006c4  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   000026ad  00000000  00000000  00000844  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000bb7  00000000  00000000  00002ef1  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00000ef3  00000000  00000000  00003aa8  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000004a8  00000000  00000000  0000499c  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00000931  00000000  00000000  00004e44  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00002678  00000000  00000000  00005775  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000140  00000000  00000000  00007ded  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
   4:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
   8:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
   c:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  10:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  14:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  18:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  1c:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  20:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  24:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  28:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  2c:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  30:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  34:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  38:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  3c:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  40:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  44:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  48:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  4c:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  50:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d8 e0       	ldi	r29, 0x08	; 8
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
  60:	10 e0       	ldi	r17, 0x00	; 0
  62:	a0 e6       	ldi	r26, 0x60	; 96
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	e6 e9       	ldi	r30, 0x96	; 150
  68:	f5 e0       	ldi	r31, 0x05	; 5
  6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
  6c:	05 90       	lpm	r0, Z+
  6e:	0d 92       	st	X+, r0
  70:	ac 3a       	cpi	r26, 0xAC	; 172
  72:	b1 07       	cpc	r27, r17
  74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>
  76:	0e 94 cb 01 	call	0x396	; 0x396 <main>
  7a:	0c 94 c9 02 	jmp	0x592	; 0x592 <_exit>

0000007e <__bad_interrupt>:
  7e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000082 <keypad_init>:
 * @param _keypad_obj pointer to the keypad configurations
 * @return Status of the function
 *          (E_OK) : The function done successfully
 *          (E_NOT_OK) : The function has issue to perform this action
 */
Std_ReturnType keypad_init(const keypad_t *_keypad_obj){
  82:	0f 93       	push	r16
  84:	1f 93       	push	r17
  86:	cf 93       	push	r28
    Std_ReturnType ret = E_OK;
    uint8 rows_counter = ZERO_INIT, columns_counter = ZERO_INIT;
    if(NULL == _keypad_obj){
  88:	00 97       	sbiw	r24, 0x00	; 0
  8a:	c9 f0       	breq	.+50     	; 0xbe <keypad_init+0x3c>
  8c:	8c 01       	movw	r16, r24
  8e:	c0 e0       	ldi	r28, 0x00	; 0
  90:	81 e0       	ldi	r24, 0x01	; 1
  92:	06 c0       	rjmp	.+12     	; 0xa0 <keypad_init+0x1e>
        ret = E_NOT_OK;
    }
    else{    
        for(rows_counter=ZERO_INIT; rows_counter<ECU_KEYPAD_ROWS; rows_counter++){
            ret = gpio_pin_init(&(_keypad_obj->keypad_row_pins[rows_counter]));
  94:	c8 01       	movw	r24, r16
  96:	8c 0f       	add	r24, r28
  98:	91 1d       	adc	r25, r1
  9a:	0e 94 b6 02 	call	0x56c	; 0x56c <gpio_pin_init>
    uint8 rows_counter = ZERO_INIT, columns_counter = ZERO_INIT;
    if(NULL == _keypad_obj){
        ret = E_NOT_OK;
    }
    else{    
        for(rows_counter=ZERO_INIT; rows_counter<ECU_KEYPAD_ROWS; rows_counter++){
  9e:	cf 5f       	subi	r28, 0xFF	; 255
  a0:	c4 30       	cpi	r28, 0x04	; 4
  a2:	c0 f3       	brcs	.-16     	; 0x94 <keypad_init+0x12>
  a4:	c0 e0       	ldi	r28, 0x00	; 0
  a6:	08 c0       	rjmp	.+16     	; 0xb8 <keypad_init+0x36>
            ret = gpio_pin_init(&(_keypad_obj->keypad_row_pins[rows_counter]));
        }
        for(columns_counter=ZERO_INIT; columns_counter<ECU_KEYPAD_COLUMNS; columns_counter++){
            ret = gpio_pin_direction_init(&(_keypad_obj->keypad_column_pins[columns_counter]));
  a8:	8c 2f       	mov	r24, r28
  aa:	90 e0       	ldi	r25, 0x00	; 0
  ac:	04 96       	adiw	r24, 0x04	; 4
  ae:	80 0f       	add	r24, r16
  b0:	91 1f       	adc	r25, r17
  b2:	0e 94 07 02 	call	0x40e	; 0x40e <gpio_pin_direction_init>
    }
    else{    
        for(rows_counter=ZERO_INIT; rows_counter<ECU_KEYPAD_ROWS; rows_counter++){
            ret = gpio_pin_init(&(_keypad_obj->keypad_row_pins[rows_counter]));
        }
        for(columns_counter=ZERO_INIT; columns_counter<ECU_KEYPAD_COLUMNS; columns_counter++){
  b6:	cf 5f       	subi	r28, 0xFF	; 255
  b8:	c6 30       	cpi	r28, 0x06	; 6
  ba:	b0 f3       	brcs	.-20     	; 0xa8 <keypad_init+0x26>
  bc:	01 c0       	rjmp	.+2      	; 0xc0 <keypad_init+0x3e>
 */
Std_ReturnType keypad_init(const keypad_t *_keypad_obj){
    Std_ReturnType ret = E_OK;
    uint8 rows_counter = ZERO_INIT, columns_counter = ZERO_INIT;
    if(NULL == _keypad_obj){
        ret = E_NOT_OK;
  be:	80 e0       	ldi	r24, 0x00	; 0
        for(columns_counter=ZERO_INIT; columns_counter<ECU_KEYPAD_COLUMNS; columns_counter++){
            ret = gpio_pin_direction_init(&(_keypad_obj->keypad_column_pins[columns_counter]));
        }
    }
    return ret;
}
  c0:	cf 91       	pop	r28
  c2:	1f 91       	pop	r17
  c4:	0f 91       	pop	r16
  c6:	08 95       	ret

000000c8 <keypad_get_value>:
 * @return Status of the function
 *          (E_OK) : The function done successfully
 *          (E_NOT_OK) : The function has issue to perform this action 
 */
Std_ReturnType keypad_get_value(const keypad_t *_keypad_obj, uint8 *value)
{
  c8:	5f 92       	push	r5
  ca:	6f 92       	push	r6
  cc:	7f 92       	push	r7
  ce:	8f 92       	push	r8
  d0:	9f 92       	push	r9
  d2:	af 92       	push	r10
  d4:	bf 92       	push	r11
  d6:	cf 92       	push	r12
  d8:	df 92       	push	r13
  da:	ef 92       	push	r14
  dc:	ff 92       	push	r15
  de:	0f 93       	push	r16
  e0:	1f 93       	push	r17
  e2:	cf 93       	push	r28
  e4:	df 93       	push	r29
  e6:	1f 92       	push	r1
  e8:	cd b7       	in	r28, 0x3d	; 61
  ea:	de b7       	in	r29, 0x3e	; 62
    Std_ReturnType ret = E_OK;
    uint8 l_rows_counter = ZERO_INIT, l_columns_counter = ZERO_INIT, l_counter = ZERO_INIT;
    uint8 column_logic = ZERO_INIT;
  ec:	19 82       	std	Y+1, r1	; 0x01
    if((NULL == _keypad_obj) || (NULL == value)){
  ee:	00 97       	sbiw	r24, 0x00	; 0
  f0:	09 f4       	brne	.+2      	; 0xf4 <keypad_get_value+0x2c>
  f2:	5e c0       	rjmp	.+188    	; 0x1b0 <keypad_get_value+0xe8>
  f4:	61 15       	cp	r22, r1
  f6:	71 05       	cpc	r23, r1
  f8:	09 f4       	brne	.+2      	; 0xfc <keypad_get_value+0x34>
  fa:	5c c0       	rjmp	.+184    	; 0x1b4 <keypad_get_value+0xec>
  fc:	5b 01       	movw	r10, r22
  fe:	7c 01       	movw	r14, r24
 100:	51 2c       	mov	r5, r1
 102:	66 24       	eor	r6, r6
 104:	63 94       	inc	r6
 106:	4f c0       	rjmp	.+158    	; 0x1a6 <keypad_get_value+0xde>
        ret = E_NOT_OK;
    }
    else{    
        for(l_rows_counter=ZERO_INIT; l_rows_counter<ECU_KEYPAD_ROWS; l_rows_counter++){
            for(l_counter=ZERO_INIT; l_counter<ECU_KEYPAD_ROWS; l_counter++){
                ret = gpio_pin_write_logic(&(_keypad_obj->keypad_row_pins[l_counter]), GPIO_LOW);
 108:	60 e0       	ldi	r22, 0x00	; 0
 10a:	c7 01       	movw	r24, r14
 10c:	81 0f       	add	r24, r17
 10e:	91 1d       	adc	r25, r1
 110:	0e 94 48 02 	call	0x490	; 0x490 <gpio_pin_write_logic>
 114:	68 2e       	mov	r6, r24
    if((NULL == _keypad_obj) || (NULL == value)){
        ret = E_NOT_OK;
    }
    else{    
        for(l_rows_counter=ZERO_INIT; l_rows_counter<ECU_KEYPAD_ROWS; l_rows_counter++){
            for(l_counter=ZERO_INIT; l_counter<ECU_KEYPAD_ROWS; l_counter++){
 116:	1f 5f       	subi	r17, 0xFF	; 255
 118:	01 c0       	rjmp	.+2      	; 0x11c <keypad_get_value+0x54>
 11a:	10 e0       	ldi	r17, 0x00	; 0
 11c:	14 30       	cpi	r17, 0x04	; 4
 11e:	a0 f3       	brcs	.-24     	; 0x108 <keypad_get_value+0x40>
                ret = gpio_pin_write_logic(&(_keypad_obj->keypad_row_pins[l_counter]), GPIO_LOW);
            }
            gpio_pin_write_logic(&(_keypad_obj->keypad_row_pins[l_rows_counter]), GPIO_HIGH);
 120:	85 2c       	mov	r8, r5
 122:	91 2c       	mov	r9, r1
 124:	61 e0       	ldi	r22, 0x01	; 1
 126:	c7 01       	movw	r24, r14
 128:	88 0d       	add	r24, r8
 12a:	99 1d       	adc	r25, r9
 12c:	0e 94 48 02 	call	0x490	; 0x490 <gpio_pin_write_logic>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 130:	83 ec       	ldi	r24, 0xC3	; 195
 132:	99 e0       	ldi	r25, 0x09	; 9
 134:	01 97       	sbiw	r24, 0x01	; 1
 136:	f1 f7       	brne	.-4      	; 0x134 <keypad_get_value+0x6c>
 138:	00 c0       	rjmp	.+0      	; 0x13a <keypad_get_value+0x72>
 13a:	00 00       	nop
            _delay_ms(10);
            for(l_columns_counter=ZERO_INIT; l_columns_counter<ECU_KEYPAD_COLUMNS; l_columns_counter++)
 13c:	71 2c       	mov	r7, r1
 13e:	2f c0       	rjmp	.+94     	; 0x19e <keypad_get_value+0xd6>
			{
                ret = gpio_pin_read_logic(&(_keypad_obj->keypad_column_pins[l_columns_counter]), &column_logic);
 140:	c7 2c       	mov	r12, r7
 142:	d1 2c       	mov	r13, r1
 144:	86 01       	movw	r16, r12
 146:	0c 5f       	subi	r16, 0xFC	; 252
 148:	1f 4f       	sbci	r17, 0xFF	; 255
 14a:	0e 0d       	add	r16, r14
 14c:	1f 1d       	adc	r17, r15
 14e:	be 01       	movw	r22, r28
 150:	6f 5f       	subi	r22, 0xFF	; 255
 152:	7f 4f       	sbci	r23, 0xFF	; 255
 154:	c8 01       	movw	r24, r16
 156:	0e 94 91 02 	call	0x522	; 0x522 <gpio_pin_read_logic>
 15a:	68 2e       	mov	r6, r24
                if(GPIO_HIGH == column_logic)
 15c:	89 81       	ldd	r24, Y+1	; 0x01
 15e:	81 30       	cpi	r24, 0x01	; 1
 160:	d9 f4       	brne	.+54     	; 0x198 <keypad_get_value+0xd0>
 162:	07 c0       	rjmp	.+14     	; 0x172 <keypad_get_value+0xaa>
				{
					while(GPIO_HIGH == column_logic)
					{
						ret = gpio_pin_read_logic(&(_keypad_obj->keypad_column_pins[l_columns_counter]), &column_logic);
 164:	be 01       	movw	r22, r28
 166:	6f 5f       	subi	r22, 0xFF	; 255
 168:	7f 4f       	sbci	r23, 0xFF	; 255
 16a:	c8 01       	movw	r24, r16
 16c:	0e 94 91 02 	call	0x522	; 0x522 <gpio_pin_read_logic>
 170:	68 2e       	mov	r6, r24
            for(l_columns_counter=ZERO_INIT; l_columns_counter<ECU_KEYPAD_COLUMNS; l_columns_counter++)
			{
                ret = gpio_pin_read_logic(&(_keypad_obj->keypad_column_pins[l_columns_counter]), &column_logic);
                if(GPIO_HIGH == column_logic)
				{
					while(GPIO_HIGH == column_logic)
 172:	89 81       	ldd	r24, Y+1	; 0x01
 174:	81 30       	cpi	r24, 0x01	; 1
 176:	b1 f3       	breq	.-20     	; 0x164 <keypad_get_value+0x9c>
					{
						ret = gpio_pin_read_logic(&(_keypad_obj->keypad_column_pins[l_columns_counter]), &column_logic);
					}
                    *value = btn_values[l_rows_counter][l_columns_counter];
 178:	c4 01       	movw	r24, r8
 17a:	88 0f       	add	r24, r24
 17c:	99 1f       	adc	r25, r25
 17e:	88 0d       	add	r24, r8
 180:	99 1d       	adc	r25, r9
 182:	88 0f       	add	r24, r24
 184:	99 1f       	adc	r25, r25
 186:	88 57       	subi	r24, 0x78	; 120
 188:	9f 4f       	sbci	r25, 0xFF	; 255
 18a:	fc 01       	movw	r30, r24
 18c:	ec 0d       	add	r30, r12
 18e:	fd 1d       	adc	r31, r13
 190:	80 81       	ld	r24, Z
 192:	f5 01       	movw	r30, r10
 194:	80 83       	st	Z, r24
				    return ret;
 196:	0f c0       	rjmp	.+30     	; 0x1b6 <keypad_get_value+0xee>
                }
				else
				{
					*value = 0;
 198:	f5 01       	movw	r30, r10
 19a:	10 82       	st	Z, r1
            for(l_counter=ZERO_INIT; l_counter<ECU_KEYPAD_ROWS; l_counter++){
                ret = gpio_pin_write_logic(&(_keypad_obj->keypad_row_pins[l_counter]), GPIO_LOW);
            }
            gpio_pin_write_logic(&(_keypad_obj->keypad_row_pins[l_rows_counter]), GPIO_HIGH);
            _delay_ms(10);
            for(l_columns_counter=ZERO_INIT; l_columns_counter<ECU_KEYPAD_COLUMNS; l_columns_counter++)
 19c:	73 94       	inc	r7
 19e:	f5 e0       	ldi	r31, 0x05	; 5
 1a0:	f7 15       	cp	r31, r7
 1a2:	70 f6       	brcc	.-100    	; 0x140 <keypad_get_value+0x78>
    uint8 column_logic = ZERO_INIT;
    if((NULL == _keypad_obj) || (NULL == value)){
        ret = E_NOT_OK;
    }
    else{    
        for(l_rows_counter=ZERO_INIT; l_rows_counter<ECU_KEYPAD_ROWS; l_rows_counter++){
 1a4:	53 94       	inc	r5
 1a6:	83 e0       	ldi	r24, 0x03	; 3
 1a8:	85 15       	cp	r24, r5
 1aa:	08 f0       	brcs	.+2      	; 0x1ae <keypad_get_value+0xe6>
 1ac:	b6 cf       	rjmp	.-148    	; 0x11a <keypad_get_value+0x52>
 1ae:	03 c0       	rjmp	.+6      	; 0x1b6 <keypad_get_value+0xee>
{
    Std_ReturnType ret = E_OK;
    uint8 l_rows_counter = ZERO_INIT, l_columns_counter = ZERO_INIT, l_counter = ZERO_INIT;
    uint8 column_logic = ZERO_INIT;
    if((NULL == _keypad_obj) || (NULL == value)){
        ret = E_NOT_OK;
 1b0:	61 2c       	mov	r6, r1
 1b2:	01 c0       	rjmp	.+2      	; 0x1b6 <keypad_get_value+0xee>
 1b4:	61 2c       	mov	r6, r1
				}
			}
        }
    }
    return ret;
 1b6:	86 2d       	mov	r24, r6
 1b8:	0f 90       	pop	r0
 1ba:	df 91       	pop	r29
 1bc:	cf 91       	pop	r28
 1be:	1f 91       	pop	r17
 1c0:	0f 91       	pop	r16
 1c2:	ff 90       	pop	r15
 1c4:	ef 90       	pop	r14
 1c6:	df 90       	pop	r13
 1c8:	cf 90       	pop	r12
 1ca:	bf 90       	pop	r11
 1cc:	af 90       	pop	r10
 1ce:	9f 90       	pop	r9
 1d0:	8f 90       	pop	r8
 1d2:	7f 90       	pop	r7
 1d4:	6f 90       	pop	r6
 1d6:	5f 90       	pop	r5
 1d8:	08 95       	ret

000001da <lcd_send_4bits>:
    Std_ReturnType ret = E_OK;
    ret = gpio_pin_write_logic(&(lcd->lcd_en), GPIO_HIGH);
    _delay_us(5);
    ret = gpio_pin_write_logic(&(lcd->lcd_en), GPIO_LOW);
    return ret;
}
 1da:	0f 93       	push	r16
 1dc:	1f 93       	push	r17
 1de:	cf 93       	push	r28
 1e0:	8c 01       	movw	r16, r24
 1e2:	c6 2f       	mov	r28, r22
 1e4:	61 70       	andi	r22, 0x01	; 1
 1e6:	02 96       	adiw	r24, 0x02	; 2
 1e8:	0e 94 48 02 	call	0x490	; 0x490 <gpio_pin_write_logic>
 1ec:	c1 fb       	bst	r28, 1
 1ee:	66 27       	eor	r22, r22
 1f0:	60 f9       	bld	r22, 0
 1f2:	c8 01       	movw	r24, r16
 1f4:	03 96       	adiw	r24, 0x03	; 3
 1f6:	0e 94 48 02 	call	0x490	; 0x490 <gpio_pin_write_logic>
 1fa:	c2 fb       	bst	r28, 2
 1fc:	66 27       	eor	r22, r22
 1fe:	60 f9       	bld	r22, 0
 200:	c8 01       	movw	r24, r16
 202:	04 96       	adiw	r24, 0x04	; 4
 204:	0e 94 48 02 	call	0x490	; 0x490 <gpio_pin_write_logic>
 208:	c3 fb       	bst	r28, 3
 20a:	66 27       	eor	r22, r22
 20c:	60 f9       	bld	r22, 0
 20e:	c8 01       	movw	r24, r16
 210:	05 96       	adiw	r24, 0x05	; 5
 212:	0e 94 48 02 	call	0x490	; 0x490 <gpio_pin_write_logic>
 216:	cf 91       	pop	r28
 218:	1f 91       	pop	r17
 21a:	0f 91       	pop	r16
 21c:	08 95       	ret

0000021e <lcd_4bit_send_enable_signal>:
 21e:	cf 93       	push	r28
 220:	df 93       	push	r29
 222:	ec 01       	movw	r28, r24
 224:	21 96       	adiw	r28, 0x01	; 1
 226:	61 e0       	ldi	r22, 0x01	; 1
 228:	ce 01       	movw	r24, r28
 22a:	0e 94 48 02 	call	0x490	; 0x490 <gpio_pin_write_logic>
 22e:	00 c0       	rjmp	.+0      	; 0x230 <lcd_4bit_send_enable_signal+0x12>
 230:	00 c0       	rjmp	.+0      	; 0x232 <lcd_4bit_send_enable_signal+0x14>
 232:	00 00       	nop
 234:	60 e0       	ldi	r22, 0x00	; 0
 236:	ce 01       	movw	r24, r28
 238:	0e 94 48 02 	call	0x490	; 0x490 <gpio_pin_write_logic>
 23c:	df 91       	pop	r29
 23e:	cf 91       	pop	r28
 240:	08 95       	ret

00000242 <lcd_4bit_send_command>:
 * @param command
 * @return Status of the function
 *          (E_OK) : The function done successfully
 *          (E_NOT_OK) : The function has issue to perform this action
 */
Std_ReturnType lcd_4bit_send_command(const chr_lcd_4bit_t *lcd, uint8 command){
 242:	1f 93       	push	r17
 244:	cf 93       	push	r28
 246:	df 93       	push	r29
    Std_ReturnType ret = E_OK;
    if(NULL == lcd){
 248:	00 97       	sbiw	r24, 0x00	; 0
 24a:	b1 f0       	breq	.+44     	; 0x278 <lcd_4bit_send_command+0x36>
 24c:	16 2f       	mov	r17, r22
 24e:	ec 01       	movw	r28, r24
        ret = E_NOT_OK;
    }
    else{
        /* R/W Pin connected to the GND -> Logic (0) "Hard Wired" */
        /* Write Logic (0) to the "Register Select" Pin to select the "Instruction Register"  */
        ret = gpio_pin_write_logic(&(lcd->lcd_rs), GPIO_LOW);
 250:	60 e0       	ldi	r22, 0x00	; 0
 252:	0e 94 48 02 	call	0x490	; 0x490 <gpio_pin_write_logic>
        /* Send the Command through the (4-Pins" Data lines */
        ret = lcd_send_4bits(lcd, command >> 4);
 256:	61 2f       	mov	r22, r17
 258:	62 95       	swap	r22
 25a:	6f 70       	andi	r22, 0x0F	; 15
 25c:	ce 01       	movw	r24, r28
 25e:	0e 94 ed 00 	call	0x1da	; 0x1da <lcd_send_4bits>
        /* Send the Enable Signal on the "E" Pin */
        ret = lcd_4bit_send_enable_signal(lcd);
 262:	ce 01       	movw	r24, r28
 264:	0e 94 0f 01 	call	0x21e	; 0x21e <lcd_4bit_send_enable_signal>
        /* Send the Command through the (4-Pins" Data lines */
        ret = lcd_send_4bits(lcd, command);
 268:	61 2f       	mov	r22, r17
 26a:	ce 01       	movw	r24, r28
 26c:	0e 94 ed 00 	call	0x1da	; 0x1da <lcd_send_4bits>
        /* Send the Enable Signal on the "E" Pin */
        ret = lcd_4bit_send_enable_signal(lcd);
 270:	ce 01       	movw	r24, r28
 272:	0e 94 0f 01 	call	0x21e	; 0x21e <lcd_4bit_send_enable_signal>
 276:	01 c0       	rjmp	.+2      	; 0x27a <lcd_4bit_send_command+0x38>
 *          (E_NOT_OK) : The function has issue to perform this action
 */
Std_ReturnType lcd_4bit_send_command(const chr_lcd_4bit_t *lcd, uint8 command){
    Std_ReturnType ret = E_OK;
    if(NULL == lcd){
        ret = E_NOT_OK;
 278:	80 e0       	ldi	r24, 0x00	; 0
        ret = lcd_send_4bits(lcd, command);
        /* Send the Enable Signal on the "E" Pin */
        ret = lcd_4bit_send_enable_signal(lcd);
    }
    return ret;
}
 27a:	df 91       	pop	r29
 27c:	cf 91       	pop	r28
 27e:	1f 91       	pop	r17
 280:	08 95       	ret

00000282 <lcd_4bit_init>:
 * @param lcd
 * @return Status of the function
 *          (E_OK) : The function done successfully
 *          (E_NOT_OK) : The function has issue to perform this action
 */
Std_ReturnType lcd_4bit_init(const chr_lcd_4bit_t *lcd){
 282:	1f 93       	push	r17
 284:	cf 93       	push	r28
 286:	df 93       	push	r29
    Std_ReturnType ret = E_OK;
    uint8 l_data_pins_counter = ZERO_INIT;
    if(NULL == lcd){
 288:	00 97       	sbiw	r24, 0x00	; 0
 28a:	09 f4       	brne	.+2      	; 0x28e <lcd_4bit_init+0xc>
 28c:	47 c0       	rjmp	.+142    	; 0x31c <lcd_4bit_init+0x9a>
 28e:	ec 01       	movw	r28, r24
        ret = E_NOT_OK;
    }
    else{    
        ret = gpio_pin_init(&(lcd->lcd_rs));
 290:	0e 94 b6 02 	call	0x56c	; 0x56c <gpio_pin_init>
        ret = gpio_pin_init(&(lcd->lcd_en));
 294:	ce 01       	movw	r24, r28
 296:	01 96       	adiw	r24, 0x01	; 1
 298:	0e 94 b6 02 	call	0x56c	; 0x56c <gpio_pin_init>
        for(l_data_pins_counter=ZERO_INIT; l_data_pins_counter<4; l_data_pins_counter++){
 29c:	10 e0       	ldi	r17, 0x00	; 0
 29e:	08 c0       	rjmp	.+16     	; 0x2b0 <lcd_4bit_init+0x2e>
            ret = gpio_pin_init(&(lcd->lcd_data[l_data_pins_counter]));
 2a0:	81 2f       	mov	r24, r17
 2a2:	90 e0       	ldi	r25, 0x00	; 0
 2a4:	02 96       	adiw	r24, 0x02	; 2
 2a6:	8c 0f       	add	r24, r28
 2a8:	9d 1f       	adc	r25, r29
 2aa:	0e 94 b6 02 	call	0x56c	; 0x56c <gpio_pin_init>
        ret = E_NOT_OK;
    }
    else{    
        ret = gpio_pin_init(&(lcd->lcd_rs));
        ret = gpio_pin_init(&(lcd->lcd_en));
        for(l_data_pins_counter=ZERO_INIT; l_data_pins_counter<4; l_data_pins_counter++){
 2ae:	1f 5f       	subi	r17, 0xFF	; 255
 2b0:	14 30       	cpi	r17, 0x04	; 4
 2b2:	b0 f3       	brcs	.-20     	; 0x2a0 <lcd_4bit_init+0x1e>
 2b4:	87 e8       	ldi	r24, 0x87	; 135
 2b6:	93 e1       	ldi	r25, 0x13	; 19
 2b8:	01 97       	sbiw	r24, 0x01	; 1
 2ba:	f1 f7       	brne	.-4      	; 0x2b8 <lcd_4bit_init+0x36>
 2bc:	00 c0       	rjmp	.+0      	; 0x2be <lcd_4bit_init+0x3c>
 2be:	00 00       	nop
            ret = gpio_pin_init(&(lcd->lcd_data[l_data_pins_counter]));
        }
        _delay_ms(20);
        ret = lcd_4bit_send_command(lcd, _LCD_8BIT_MODE_2_LINE);
 2c0:	68 e3       	ldi	r22, 0x38	; 56
 2c2:	ce 01       	movw	r24, r28
 2c4:	0e 94 21 01 	call	0x242	; 0x242 <lcd_4bit_send_command>
 2c8:	81 ee       	ldi	r24, 0xE1	; 225
 2ca:	94 e0       	ldi	r25, 0x04	; 4
 2cc:	01 97       	sbiw	r24, 0x01	; 1
 2ce:	f1 f7       	brne	.-4      	; 0x2cc <lcd_4bit_init+0x4a>
 2d0:	00 c0       	rjmp	.+0      	; 0x2d2 <lcd_4bit_init+0x50>
 2d2:	00 00       	nop
        _delay_ms(5);
        ret = lcd_4bit_send_command(lcd, _LCD_8BIT_MODE_2_LINE);
 2d4:	68 e3       	ldi	r22, 0x38	; 56
 2d6:	ce 01       	movw	r24, r28
 2d8:	0e 94 21 01 	call	0x242	; 0x242 <lcd_4bit_send_command>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 2dc:	92 e3       	ldi	r25, 0x32	; 50
 2de:	9a 95       	dec	r25
 2e0:	f1 f7       	brne	.-4      	; 0x2de <lcd_4bit_init+0x5c>
        _delay_us(150);
        ret = lcd_4bit_send_command(lcd, _LCD_8BIT_MODE_2_LINE);
 2e2:	68 e3       	ldi	r22, 0x38	; 56
 2e4:	ce 01       	movw	r24, r28
 2e6:	0e 94 21 01 	call	0x242	; 0x242 <lcd_4bit_send_command>
        
        ret = lcd_4bit_send_command(lcd, _LCD_CLEAR);
 2ea:	61 e0       	ldi	r22, 0x01	; 1
 2ec:	ce 01       	movw	r24, r28
 2ee:	0e 94 21 01 	call	0x242	; 0x242 <lcd_4bit_send_command>
        ret = lcd_4bit_send_command(lcd, _LCD_RETURN_HOME);
 2f2:	62 e0       	ldi	r22, 0x02	; 2
 2f4:	ce 01       	movw	r24, r28
 2f6:	0e 94 21 01 	call	0x242	; 0x242 <lcd_4bit_send_command>
        ret = lcd_4bit_send_command(lcd, _LCD_ENTRY_MODE_INC_SHIFT_OFF);
 2fa:	66 e0       	ldi	r22, 0x06	; 6
 2fc:	ce 01       	movw	r24, r28
 2fe:	0e 94 21 01 	call	0x242	; 0x242 <lcd_4bit_send_command>
        ret = lcd_4bit_send_command(lcd, _LCD_DISPLAY_ON_UNDERLINE_OFF_CURSOR_OFF);
 302:	6c e0       	ldi	r22, 0x0C	; 12
 304:	ce 01       	movw	r24, r28
 306:	0e 94 21 01 	call	0x242	; 0x242 <lcd_4bit_send_command>
        ret = lcd_4bit_send_command(lcd, _LCD_4BIT_MODE_2_LINE);
 30a:	68 e2       	ldi	r22, 0x28	; 40
 30c:	ce 01       	movw	r24, r28
 30e:	0e 94 21 01 	call	0x242	; 0x242 <lcd_4bit_send_command>
        ret = lcd_4bit_send_command(lcd, 0x80);
 312:	60 e8       	ldi	r22, 0x80	; 128
 314:	ce 01       	movw	r24, r28
 316:	0e 94 21 01 	call	0x242	; 0x242 <lcd_4bit_send_command>
 31a:	01 c0       	rjmp	.+2      	; 0x31e <lcd_4bit_init+0x9c>
 */
Std_ReturnType lcd_4bit_init(const chr_lcd_4bit_t *lcd){
    Std_ReturnType ret = E_OK;
    uint8 l_data_pins_counter = ZERO_INIT;
    if(NULL == lcd){
        ret = E_NOT_OK;
 31c:	80 e0       	ldi	r24, 0x00	; 0
        ret = lcd_4bit_send_command(lcd, _LCD_DISPLAY_ON_UNDERLINE_OFF_CURSOR_OFF);
        ret = lcd_4bit_send_command(lcd, _LCD_4BIT_MODE_2_LINE);
        ret = lcd_4bit_send_command(lcd, 0x80);
    }
    return ret;
}
 31e:	df 91       	pop	r29
 320:	cf 91       	pop	r28
 322:	1f 91       	pop	r17
 324:	08 95       	ret

00000326 <lcd_4bit_send_char_data>:
 * @param data The data that we need to send to the LCD
 * @return Status of the function
 *          (E_OK) : The function done successfully
 *          (E_NOT_OK) : The function has issue to perform this action
 */
Std_ReturnType lcd_4bit_send_char_data(const chr_lcd_4bit_t *lcd, uint8 data){
 326:	1f 93       	push	r17
 328:	cf 93       	push	r28
 32a:	df 93       	push	r29
    Std_ReturnType ret = E_OK;
    if(NULL == lcd){
 32c:	00 97       	sbiw	r24, 0x00	; 0
 32e:	b1 f0       	breq	.+44     	; 0x35c <lcd_4bit_send_char_data+0x36>
 330:	16 2f       	mov	r17, r22
 332:	ec 01       	movw	r28, r24
        ret = E_NOT_OK;
    }
    else{    
        /* R/W Pin connected to the GND -> Logic (0) "Hard Wired" */
        /* Write Logic (1) to the "Register Select" Pin to select the "Data Register"  */
        ret = gpio_pin_write_logic(&(lcd->lcd_rs), GPIO_HIGH);
 334:	61 e0       	ldi	r22, 0x01	; 1
 336:	0e 94 48 02 	call	0x490	; 0x490 <gpio_pin_write_logic>
        /* Send the Data through the (4-Pins" Data lines */
        ret = lcd_send_4bits(lcd, data >> 4);
 33a:	61 2f       	mov	r22, r17
 33c:	62 95       	swap	r22
 33e:	6f 70       	andi	r22, 0x0F	; 15
 340:	ce 01       	movw	r24, r28
 342:	0e 94 ed 00 	call	0x1da	; 0x1da <lcd_send_4bits>
        /* Send the Enable Signal on the "E" Pin */
        ret = lcd_4bit_send_enable_signal(lcd);
 346:	ce 01       	movw	r24, r28
 348:	0e 94 0f 01 	call	0x21e	; 0x21e <lcd_4bit_send_enable_signal>
        /* Send the Data through the (4-Pins" Data lines */
        ret = lcd_send_4bits(lcd, data);
 34c:	61 2f       	mov	r22, r17
 34e:	ce 01       	movw	r24, r28
 350:	0e 94 ed 00 	call	0x1da	; 0x1da <lcd_send_4bits>
        /* Send the Enable Signal on the "E" Pin */
        ret = lcd_4bit_send_enable_signal(lcd);
 354:	ce 01       	movw	r24, r28
 356:	0e 94 0f 01 	call	0x21e	; 0x21e <lcd_4bit_send_enable_signal>
 35a:	01 c0       	rjmp	.+2      	; 0x35e <lcd_4bit_send_char_data+0x38>
 *          (E_NOT_OK) : The function has issue to perform this action
 */
Std_ReturnType lcd_4bit_send_char_data(const chr_lcd_4bit_t *lcd, uint8 data){
    Std_ReturnType ret = E_OK;
    if(NULL == lcd){
        ret = E_NOT_OK;
 35c:	80 e0       	ldi	r24, 0x00	; 0
        ret = lcd_send_4bits(lcd, data);
        /* Send the Enable Signal on the "E" Pin */
        ret = lcd_4bit_send_enable_signal(lcd);
    }
    return ret;
}
 35e:	df 91       	pop	r29
 360:	cf 91       	pop	r28
 362:	1f 91       	pop	r17
 364:	08 95       	ret

00000366 <lcd_4bit_send_string>:
 * @param str
 * @return Status of the function
 *          (E_OK) : The function done successfully
 *          (E_NOT_OK) : The function has issue to perform this action
 */
Std_ReturnType lcd_4bit_send_string(const chr_lcd_4bit_t *lcd, uint8 *str){
 366:	0f 93       	push	r16
 368:	1f 93       	push	r17
 36a:	cf 93       	push	r28
 36c:	df 93       	push	r29
 36e:	8c 01       	movw	r16, r24
 370:	eb 01       	movw	r28, r22
    Std_ReturnType ret = E_OK;
    if(NULL == lcd){
 372:	89 2b       	or	r24, r25
 374:	51 f0       	breq	.+20     	; 0x38a <lcd_4bit_send_string+0x24>
 376:	81 e0       	ldi	r24, 0x01	; 1
 378:	04 c0       	rjmp	.+8      	; 0x382 <lcd_4bit_send_string+0x1c>
        ret = E_NOT_OK;
    }
    else{    
        while(*str){
            ret = lcd_4bit_send_char_data(lcd, *str++);
 37a:	21 96       	adiw	r28, 0x01	; 1
 37c:	c8 01       	movw	r24, r16
 37e:	0e 94 93 01 	call	0x326	; 0x326 <lcd_4bit_send_char_data>
    Std_ReturnType ret = E_OK;
    if(NULL == lcd){
        ret = E_NOT_OK;
    }
    else{    
        while(*str){
 382:	68 81       	ld	r22, Y
 384:	61 11       	cpse	r22, r1
 386:	f9 cf       	rjmp	.-14     	; 0x37a <lcd_4bit_send_string+0x14>
 388:	01 c0       	rjmp	.+2      	; 0x38c <lcd_4bit_send_string+0x26>
 *          (E_NOT_OK) : The function has issue to perform this action
 */
Std_ReturnType lcd_4bit_send_string(const chr_lcd_4bit_t *lcd, uint8 *str){
    Std_ReturnType ret = E_OK;
    if(NULL == lcd){
        ret = E_NOT_OK;
 38a:	80 e0       	ldi	r24, 0x00	; 0
        while(*str){
            ret = lcd_4bit_send_char_data(lcd, *str++);
        }
    }
    return ret;
}
 38c:	df 91       	pop	r29
 38e:	cf 91       	pop	r28
 390:	1f 91       	pop	r17
 392:	0f 91       	pop	r16
 394:	08 95       	ret

00000396 <main>:
	.keypad_column_pins[3].logic = GPIO_LOW
};


int main(void)
{
 396:	cf 93       	push	r28
 398:	df 93       	push	r29
 39a:	cd b7       	in	r28, 0x3d	; 61
 39c:	de b7       	in	r29, 0x3e	; 62
 39e:	2c 97       	sbiw	r28, 0x0c	; 12
 3a0:	0f b6       	in	r0, 0x3f	; 63
 3a2:	f8 94       	cli
 3a4:	de bf       	out	0x3e, r29	; 62
 3a6:	0f be       	out	0x3f, r0	; 63
 3a8:	cd bf       	out	0x3d, r28	; 61
	/* Initialize LCD and Keypad */
	lcd_4bit_init(&_lcd);
 3aa:	8a e6       	ldi	r24, 0x6A	; 106
 3ac:	90 e0       	ldi	r25, 0x00	; 0
 3ae:	0e 94 41 01 	call	0x282	; 0x282 <lcd_4bit_init>
	keypad_init(&_keypad);
 3b2:	80 e6       	ldi	r24, 0x60	; 96
 3b4:	90 e0       	ldi	r25, 0x00	; 0
 3b6:	0e 94 41 00 	call	0x82	; 0x82 <keypad_init>

	char message[11] = "HELLO LCD!";
 3ba:	8b e0       	ldi	r24, 0x0B	; 11
 3bc:	e0 ea       	ldi	r30, 0xA0	; 160
 3be:	f0 e0       	ldi	r31, 0x00	; 0
 3c0:	de 01       	movw	r26, r28
 3c2:	11 96       	adiw	r26, 0x01	; 1
 3c4:	01 90       	ld	r0, Z+
 3c6:	0d 92       	st	X+, r0
 3c8:	8a 95       	dec	r24
 3ca:	e1 f7       	brne	.-8      	; 0x3c4 <main+0x2e>
	lcd_4bit_send_string(&_lcd, message);
 3cc:	be 01       	movw	r22, r28
 3ce:	6f 5f       	subi	r22, 0xFF	; 255
 3d0:	7f 4f       	sbci	r23, 0xFF	; 255
 3d2:	8a e6       	ldi	r24, 0x6A	; 106
 3d4:	90 e0       	ldi	r25, 0x00	; 0
 3d6:	0e 94 b3 01 	call	0x366	; 0x366 <lcd_4bit_send_string>
	char key;
	
	while (1)
	{
		/* Scan keypad for input */
		keypad_get_value(&_keypad,&key);
 3da:	be 01       	movw	r22, r28
 3dc:	64 5f       	subi	r22, 0xF4	; 244
 3de:	7f 4f       	sbci	r23, 0xFF	; 255
 3e0:	80 e6       	ldi	r24, 0x60	; 96
 3e2:	90 e0       	ldi	r25, 0x00	; 0
 3e4:	0e 94 64 00 	call	0xc8	; 0xc8 <keypad_get_value>
		if(key != 0)
 3e8:	6c 85       	ldd	r22, Y+12	; 0x0c
 3ea:	66 23       	and	r22, r22
 3ec:	51 f0       	breq	.+20     	; 0x402 <__EEPROM_REGION_LENGTH__+0x2>
		{
			lcd_4bit_send_char_data(&_lcd,key);
 3ee:	8a e6       	ldi	r24, 0x6A	; 106
 3f0:	90 e0       	ldi	r25, 0x00	; 0
 3f2:	0e 94 93 01 	call	0x326	; 0x326 <lcd_4bit_send_char_data>
			lcd_4bit_send_command(&_lcd,_LCD_CLEAR);
 3f6:	61 e0       	ldi	r22, 0x01	; 1
 3f8:	8a e6       	ldi	r24, 0x6A	; 106
 3fa:	90 e0       	ldi	r25, 0x00	; 0
 3fc:	0e 94 21 01 	call	0x242	; 0x242 <lcd_4bit_send_command>
 400:	ec cf       	rjmp	.-40     	; 0x3da <main+0x44>
		}
		else
		{
			lcd_4bit_send_char_data(&_lcd,'d');
 402:	64 e6       	ldi	r22, 0x64	; 100
 404:	8a e6       	ldi	r24, 0x6A	; 106
 406:	90 e0       	ldi	r25, 0x00	; 0
 408:	0e 94 93 01 	call	0x326	; 0x326 <lcd_4bit_send_char_data>
 40c:	e6 cf       	rjmp	.-52     	; 0x3da <main+0x44>

0000040e <gpio_pin_direction_init>:
    else
    {
        TOGGLE_BIT(*port_registers[_pin_config->port], _pin_config->pin);
    }
    return ret;
}
 40e:	fc 01       	movw	r30, r24
 410:	89 2b       	or	r24, r25
 412:	d1 f1       	breq	.+116    	; 0x488 <gpio_pin_direction_init+0x7a>
 414:	20 81       	ld	r18, Z
 416:	26 95       	lsr	r18
 418:	26 95       	lsr	r18
 41a:	26 95       	lsr	r18
 41c:	27 70       	andi	r18, 0x07	; 7
 41e:	80 81       	ld	r24, Z
 420:	86 fb       	bst	r24, 6
 422:	99 27       	eor	r25, r25
 424:	90 f9       	bld	r25, 0
 426:	86 ff       	sbrs	r24, 6
 428:	18 c0       	rjmp	.+48     	; 0x45a <gpio_pin_direction_init+0x4c>
 42a:	91 30       	cpi	r25, 0x01	; 1
 42c:	79 f5       	brne	.+94     	; 0x48c <gpio_pin_direction_init+0x7e>
 42e:	e8 2f       	mov	r30, r24
 430:	e7 70       	andi	r30, 0x07	; 7
 432:	f0 e0       	ldi	r31, 0x00	; 0
 434:	ee 0f       	add	r30, r30
 436:	ff 1f       	adc	r31, r31
 438:	e8 58       	subi	r30, 0x88	; 136
 43a:	ff 4f       	sbci	r31, 0xFF	; 255
 43c:	01 90       	ld	r0, Z+
 43e:	f0 81       	ld	r31, Z
 440:	e0 2d       	mov	r30, r0
 442:	30 81       	ld	r19, Z
 444:	81 e0       	ldi	r24, 0x01	; 1
 446:	90 e0       	ldi	r25, 0x00	; 0
 448:	02 c0       	rjmp	.+4      	; 0x44e <gpio_pin_direction_init+0x40>
 44a:	88 0f       	add	r24, r24
 44c:	99 1f       	adc	r25, r25
 44e:	2a 95       	dec	r18
 450:	e2 f7       	brpl	.-8      	; 0x44a <gpio_pin_direction_init+0x3c>
 452:	83 2b       	or	r24, r19
 454:	80 83       	st	Z, r24
 456:	81 e0       	ldi	r24, 0x01	; 1
 458:	08 95       	ret
 45a:	e0 81       	ld	r30, Z
 45c:	e7 70       	andi	r30, 0x07	; 7
 45e:	f0 e0       	ldi	r31, 0x00	; 0
 460:	ee 0f       	add	r30, r30
 462:	ff 1f       	adc	r31, r31
 464:	e8 58       	subi	r30, 0x88	; 136
 466:	ff 4f       	sbci	r31, 0xFF	; 255
 468:	01 90       	ld	r0, Z+
 46a:	f0 81       	ld	r31, Z
 46c:	e0 2d       	mov	r30, r0
 46e:	30 81       	ld	r19, Z
 470:	81 e0       	ldi	r24, 0x01	; 1
 472:	90 e0       	ldi	r25, 0x00	; 0
 474:	02 c0       	rjmp	.+4      	; 0x47a <gpio_pin_direction_init+0x6c>
 476:	88 0f       	add	r24, r24
 478:	99 1f       	adc	r25, r25
 47a:	2a 95       	dec	r18
 47c:	e2 f7       	brpl	.-8      	; 0x476 <gpio_pin_direction_init+0x68>
 47e:	80 95       	com	r24
 480:	83 23       	and	r24, r19
 482:	80 83       	st	Z, r24
 484:	81 e0       	ldi	r24, 0x01	; 1
 486:	08 95       	ret
 488:	80 e0       	ldi	r24, 0x00	; 0
 48a:	08 95       	ret
 48c:	80 e0       	ldi	r24, 0x00	; 0
 48e:	08 95       	ret

00000490 <gpio_pin_write_logic>:
 490:	00 97       	sbiw	r24, 0x00	; 0
 492:	09 f4       	brne	.+2      	; 0x496 <gpio_pin_write_logic+0x6>
 494:	42 c0       	rjmp	.+132    	; 0x51a <gpio_pin_write_logic+0x8a>
 496:	66 23       	and	r22, r22
 498:	09 f1       	breq	.+66     	; 0x4dc <gpio_pin_write_logic+0x4c>
 49a:	61 30       	cpi	r22, 0x01	; 1
 49c:	09 f0       	breq	.+2      	; 0x4a0 <gpio_pin_write_logic+0x10>
 49e:	3f c0       	rjmp	.+126    	; 0x51e <gpio_pin_write_logic+0x8e>
 4a0:	fc 01       	movw	r30, r24
 4a2:	80 81       	ld	r24, Z
 4a4:	e8 2f       	mov	r30, r24
 4a6:	e7 70       	andi	r30, 0x07	; 7
 4a8:	f0 e0       	ldi	r31, 0x00	; 0
 4aa:	ee 0f       	add	r30, r30
 4ac:	ff 1f       	adc	r31, r31
 4ae:	e0 59       	subi	r30, 0x90	; 144
 4b0:	ff 4f       	sbci	r31, 0xFF	; 255
 4b2:	01 90       	ld	r0, Z+
 4b4:	f0 81       	ld	r31, Z
 4b6:	e0 2d       	mov	r30, r0
 4b8:	40 81       	ld	r20, Z
 4ba:	86 95       	lsr	r24
 4bc:	86 95       	lsr	r24
 4be:	86 95       	lsr	r24
 4c0:	87 70       	andi	r24, 0x07	; 7
 4c2:	21 e0       	ldi	r18, 0x01	; 1
 4c4:	30 e0       	ldi	r19, 0x00	; 0
 4c6:	b9 01       	movw	r22, r18
 4c8:	02 c0       	rjmp	.+4      	; 0x4ce <gpio_pin_write_logic+0x3e>
 4ca:	66 0f       	add	r22, r22
 4cc:	77 1f       	adc	r23, r23
 4ce:	8a 95       	dec	r24
 4d0:	e2 f7       	brpl	.-8      	; 0x4ca <gpio_pin_write_logic+0x3a>
 4d2:	cb 01       	movw	r24, r22
 4d4:	84 2b       	or	r24, r20
 4d6:	80 83       	st	Z, r24
 4d8:	81 e0       	ldi	r24, 0x01	; 1
 4da:	08 95       	ret
 4dc:	fc 01       	movw	r30, r24
 4de:	80 81       	ld	r24, Z
 4e0:	e8 2f       	mov	r30, r24
 4e2:	e7 70       	andi	r30, 0x07	; 7
 4e4:	f0 e0       	ldi	r31, 0x00	; 0
 4e6:	ee 0f       	add	r30, r30
 4e8:	ff 1f       	adc	r31, r31
 4ea:	e0 59       	subi	r30, 0x90	; 144
 4ec:	ff 4f       	sbci	r31, 0xFF	; 255
 4ee:	01 90       	ld	r0, Z+
 4f0:	f0 81       	ld	r31, Z
 4f2:	e0 2d       	mov	r30, r0
 4f4:	40 81       	ld	r20, Z
 4f6:	86 95       	lsr	r24
 4f8:	86 95       	lsr	r24
 4fa:	86 95       	lsr	r24
 4fc:	87 70       	andi	r24, 0x07	; 7
 4fe:	21 e0       	ldi	r18, 0x01	; 1
 500:	30 e0       	ldi	r19, 0x00	; 0
 502:	b9 01       	movw	r22, r18
 504:	02 c0       	rjmp	.+4      	; 0x50a <gpio_pin_write_logic+0x7a>
 506:	66 0f       	add	r22, r22
 508:	77 1f       	adc	r23, r23
 50a:	8a 95       	dec	r24
 50c:	e2 f7       	brpl	.-8      	; 0x506 <gpio_pin_write_logic+0x76>
 50e:	cb 01       	movw	r24, r22
 510:	80 95       	com	r24
 512:	84 23       	and	r24, r20
 514:	80 83       	st	Z, r24
 516:	81 e0       	ldi	r24, 0x01	; 1
 518:	08 95       	ret
 51a:	80 e0       	ldi	r24, 0x00	; 0
 51c:	08 95       	ret
 51e:	80 e0       	ldi	r24, 0x00	; 0
 520:	08 95       	ret

00000522 <gpio_pin_read_logic>:
 522:	00 97       	sbiw	r24, 0x00	; 0
 524:	f9 f0       	breq	.+62     	; 0x564 <gpio_pin_read_logic+0x42>
 526:	61 15       	cp	r22, r1
 528:	71 05       	cpc	r23, r1
 52a:	f1 f0       	breq	.+60     	; 0x568 <gpio_pin_read_logic+0x46>
 52c:	fc 01       	movw	r30, r24
 52e:	20 81       	ld	r18, Z
 530:	e2 2f       	mov	r30, r18
 532:	e7 70       	andi	r30, 0x07	; 7
 534:	f0 e0       	ldi	r31, 0x00	; 0
 536:	ee 0f       	add	r30, r30
 538:	ff 1f       	adc	r31, r31
 53a:	e0 58       	subi	r30, 0x80	; 128
 53c:	ff 4f       	sbci	r31, 0xFF	; 255
 53e:	01 90       	ld	r0, Z+
 540:	f0 81       	ld	r31, Z
 542:	e0 2d       	mov	r30, r0
 544:	80 81       	ld	r24, Z
 546:	26 95       	lsr	r18
 548:	26 95       	lsr	r18
 54a:	26 95       	lsr	r18
 54c:	27 70       	andi	r18, 0x07	; 7
 54e:	90 e0       	ldi	r25, 0x00	; 0
 550:	02 c0       	rjmp	.+4      	; 0x556 <gpio_pin_read_logic+0x34>
 552:	95 95       	asr	r25
 554:	87 95       	ror	r24
 556:	2a 95       	dec	r18
 558:	e2 f7       	brpl	.-8      	; 0x552 <gpio_pin_read_logic+0x30>
 55a:	81 70       	andi	r24, 0x01	; 1
 55c:	fb 01       	movw	r30, r22
 55e:	80 83       	st	Z, r24
 560:	81 e0       	ldi	r24, 0x01	; 1
 562:	08 95       	ret
 564:	80 e0       	ldi	r24, 0x00	; 0
 566:	08 95       	ret
 568:	80 e0       	ldi	r24, 0x00	; 0
 56a:	08 95       	ret

0000056c <gpio_pin_init>:
 * 
 * @param _pin_config Pointer to pin configuration structure
 * @return Std_ReturnType E_OK if successful, E_NOT_OK if error
 */
Std_ReturnType gpio_pin_init(const pin_config_t *_pin_config)
{
 56c:	cf 93       	push	r28
 56e:	df 93       	push	r29
    Std_ReturnType ret = E_OK;
    if ((NULL == _pin_config) || (_pin_config->pin > (PORT_PIN_MAX_NUMBER - 1)))
 570:	00 97       	sbiw	r24, 0x00	; 0
 572:	59 f0       	breq	.+22     	; 0x58a <gpio_pin_init+0x1e>
 574:	ec 01       	movw	r28, r24
    {
        ret = E_NOT_OK;
    }
    else
    {
        ret = gpio_pin_direction_init(_pin_config);
 576:	0e 94 07 02 	call	0x40e	; 0x40e <gpio_pin_direction_init>
        ret = gpio_pin_write_logic(_pin_config, _pin_config->logic);
 57a:	68 81       	ld	r22, Y
 57c:	67 fb       	bst	r22, 7
 57e:	66 27       	eor	r22, r22
 580:	60 f9       	bld	r22, 0
 582:	ce 01       	movw	r24, r28
 584:	0e 94 48 02 	call	0x490	; 0x490 <gpio_pin_write_logic>
 588:	01 c0       	rjmp	.+2      	; 0x58c <gpio_pin_init+0x20>
Std_ReturnType gpio_pin_init(const pin_config_t *_pin_config)
{
    Std_ReturnType ret = E_OK;
    if ((NULL == _pin_config) || (_pin_config->pin > (PORT_PIN_MAX_NUMBER - 1)))
    {
        ret = E_NOT_OK;
 58a:	80 e0       	ldi	r24, 0x00	; 0
    {
        ret = gpio_pin_direction_init(_pin_config);
        ret = gpio_pin_write_logic(_pin_config, _pin_config->logic);
    }
    return ret;
}
 58c:	df 91       	pop	r29
 58e:	cf 91       	pop	r28
 590:	08 95       	ret

00000592 <_exit>:
 592:	f8 94       	cli

00000594 <__stop_program>:
 594:	ff cf       	rjmp	.-2      	; 0x594 <__stop_program>
